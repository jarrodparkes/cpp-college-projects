At the beginning of this chapter, we demonstrated how to search for an element in a binary search tree.  That is, we first check whether the item is in the root.  If it is not, we compare the element with the root and look in either the left or the right subtree.  This statement looks recursive.  Let's apply the general guidelines for determining recursive solutions.  We have two choices for the size of the problem: the number of nodes in the tree or the number of nodes in the path from the root to the node for which we are searching (or until we reach an empty tree.)  Either is acceptable.  The first is easier to say; the second is more precise.  One base case arises when we find the element with the same key; another occurs when we determine that an element with the same key is not in the tree.  The general case is either to retrieve the element from the left subtree or to retrieve it from the right subtree.  Because the left or right subtree is at least one node smaller than the original tree and one level deeper, the size decreases with each call.  Only one more question remains: How do we know there is no item with the same key in the tree?  If the tree is empty, then it cannot contain an item with the same key as item's key.  Let's summarize these observations.  We define a recursive routine Retrieve, which is invoked by the RetrieveItem member function.