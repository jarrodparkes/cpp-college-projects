///////////////////////////////////////////////////////////////////////////
//
//  FILENAME: Driver.cpp
//
//  PROJECT: CS 221 - Programming Assignment #3
//
//  AUTHOR: Jarrod Parkes
//
//  DEVELOPMENT COMPILER: Microsoft Visual Studio 2008 Express Edition
//
//  TARGET PLATFORM: Windows 32-Bit Operating System
//
//  DESCRIPTION: This file generates the GUI interface that allows the
//				 manipulation of the BinarySearchTree ADT's methods
//				 and data members.
//
//  USAGE RESTIRCTIONS: Client privileges strictly granted to: 
//                      Jarrod Parkes, Dr. Lois Harper, UAH CS Department
//
//  HISTORY:
//  Date        Version         Reason for Change
//  04-19-10    I               Started the initial version.
//
//  NOTES: - The menu items are case sensitive and must be in CAPS.
//         - Added two special functions to help aid in the re-drawing
//           of a menu and processing of user inputs.
//
///////////////////////////////////////////////////////////////////////////

#include <iostream>				// included for standard I/O support
#include "BinarySearchTree.h"	// included to access the BST ADT interface

using namespace std;

// menu display function prototype
bool DisplayNewMenu(BinarySearchTree&, ofstream&);
// processing menu input function prototype
bool ProcessSelection(BinarySearchTree&, ofstream&, string);

int main()
{
	// instantiate BST object
	BinarySearchTree tree;

	// open the output file for all outputs executed during one program session
	ofstream myOutFile("unknown.txt");
	ofstream treeFile("finalTree.txt");

	// infinitely loop the menu, until user specifies to quit by entering "QU"
	bool menu = true;
	while(menu)
	{
		menu = DisplayNewMenu(tree, myOutFile);
	}

	tree.PrintTreeToFile(treeFile);

	// close the output file
	myOutFile.close();
	return 0;
}

///////////////////////////////////////////////////////////////////////////
//
//  Method Name: DisplayNewMenu(BST &tree, ofstream &outputFile)
//
//  Purpose: Display all menu items and query the user for an input.
//
//  Inputs: tree - the instance of a BST to be modified by menu functions.
//			outputFile - the ofstream variable which is referencing a valid
//						 file location for writing of contents to take place.
//
//  Outputs: All menu items with their associated key values and functions.
//			 Also, various menu functions have associated print statements
//			 to verify if functions completed, failed, etc.
//
//  Returns: Return value = (has the user specified to quit?).
//						  = user inputs "QU".				
//
//  Preconditions: BST has been initialized.
//
//  Postconditions: All menu functions behave as the user would expect based
//					upon the User's Manual and common sense reasoning.
//
//	Notes: None
//
///////////////////////////////////////////////////////////////////////////
bool DisplayNewMenu(BinarySearchTree &tree, ofstream &outputFile)
{
	string menuSelection = "";

	// menu display
	cout<<"Program Assignment #3 - SpellChecker BST\n\n";
	cout<<"I - Insert Word\n";
	cout<<"S - Search for Word\n";
	cout<<"R - Read-In Dictionary of Words from File\n";
	cout<<"C - Check Word for Spelling\n";
	cout<<"CP - Check Paragraph for Spelling\n";
	cout<<"QU - Quit\n\n";

	// selection display
	cout<<"Select Menu Item: ";
	cin>>menuSelection;

	// process selection
	return ProcessSelection(tree, outputFile, menuSelection);
}

///////////////////////////////////////////////////////////////////////////
//
//  Method Name: ProcessSelection(BST &tree, ofstream &outputFile, 
//												string menuSelection)
//
//  Purpose: Process user input and correctly call according BST functions.
//			 Also, handle invalid input and quit the program when key value
//			 matches "QU".
//
//  Inputs: tree - the instance of a BST to be modified by menu functions.
//			outputFile - the ofstream variable which is referencing a valid
//						 file location for writing of contents to take place.
//			menuSelection - the string input to be processed
//
//  Outputs: The print statements generated by various menu functions as to 
//			 verify if the functions have completed, failed, etc.
//
//  Returns: Return value = (has the user specified to quit?).
//						  = user inputs "QU".
//
//  Preconditions: BST has been initialized.
//
//  Postconditions: All menu functions behave as the user would expect based
//					upon the User's Manual and common sense reasoning. 
//
//	Notes: - If a user inputs "garbage", then this function ignores that
//			 input and redraws the menu.
//		   - Because Dr. Harper required certain menu keys to be multiple
//			 characters, the only way to handle various inputs was with
//			 multiple if-else statements.  Whereas, switch statements may
//			 have been desirable in the ideal situation.
//
///////////////////////////////////////////////////////////////////////////
bool ProcessSelection(BinarySearchTree &tree, ofstream &outputFile, string menuSelection)
{
	system("cls");

	// user selects - Insert Word
	if(menuSelection == "I")
	{
		string word = "";

		cout<<"Insert: ";
		getchar();
		getline(cin, word);

		tree.InsertItem(word);
		
		system("cls");

		cout<<"NOTE: Insert may have failed silently if height capacity was exceeded!\n\n";

		return true;
	}

	// user selects - Search For Word
	else if(menuSelection == "S")
	{
		string word = "";
		bool found = false;

		cout<<"Search: ";
		getchar();
		getline(cin, word);

		found = tree.SearchForItem(word);

		system("cls");

		if(found)
		{
			cout<<"WORD FOUND\n\n";
		}
		else
		{
			cout<<"WORD NOT FOUND\n\n";
		}

		return true;
	}

	// user selects - Read Dictionary File
	else if(menuSelection == "R")
	{
		ifstream inFile;
		string fileName = "";

		cout<<"Dictionary File Name: ";
		cin>>fileName;

		inFile.open(fileName.c_str());

		tree.AddDictionaryFile(inFile);

		system("cls");

		cout<<"NOTE: Inserts may have failed silently if height capacity was exceeded!\n\n";

		return true;
	}

	// user selects - Check Word Spelling
	else if(menuSelection == "C")
	{
		string word = "";
		bool found = false;

		cout<<"Check Spelling: ";
		getchar();
		getline(cin, word);

		found = tree.SearchForItem(word);

		system("cls");

		if(found)
		{
			cout<<"SPELLED CORRECTLY\n\n";
		}
		else
		{
			cout<<"SPELLED INCORRECTLY\n";
			cout<<"NOTE: See unknown.txt after program closes\n\n";
			outputFile<<word<<endl;
		}

		return true;
	}

	// user selects - Check Paragraph Spelling
	else if(menuSelection == "CP")
	{
		ifstream inFile;
		string fileName = "";

		cout<<"Paragraph File Name: ";
		cin>>fileName;

		inFile.open(fileName.c_str());

		tree.CheckFile(inFile, outputFile);

		system("cls");

		cout<<"NOTE: See unknown.txt after program closes for mispelled words\n\n";

		return true;
	}

	// user selects - QUIT
	else if(menuSelection == "QU")
	{
		return false;
	}

	// user selects - key value not on the menu!
	else
	{
		cout<<"INVALID INPUT\n\n";
		return true;
	}
}